{"version":3,"names":["getActiveElement","root","document","activeEl","activeElement","isEmpty","shadowRoot","baseModalCss","BsBaseModal","async","this","modalCanBeClosed","bsModalIsClosing","emit","modalId","el","classList","add","documentElement","remove","addEventListener","bsModalIsClosed","bsNextSlideAction","bsPreviousSlideAction","focusableElements","deepQuerySelectorAll","firstElementChild","firstFocusableElement","lastFocusableElement","length","_a","focus","preventScroll","handleKeyPress","e","key","handleFocusTrap","close","shiftKeyIsPressed","shiftKey","preventDefault","componentDidLoad","bind","handleFocus","previousFocusedElement","disconnectedCallback","removeEventListener","render","h","Host","class","transitionType","containerCss","BsContainer","mobileFullWidth","contained"],"sources":["./src/utils/getActiveElement.ts","./src/components/organisms/base-modal/base-modal.scss?tag=bs-base-modal&encapsulation=shadow","./src/components/organisms/base-modal/base-modal.tsx","./src/components/molecules/container/container.scss?tag=bs-container","./src/components/molecules/container/container.tsx"],"sourcesContent":["/**\n * https://www.abeautifulsite.net/posts/finding-the-active-element-in-a-shadow-root/\n *\n * You can get the focused element with document.activeElement but,\n * if it's inside a shadow root, this will be the host element.\n *\n * Here's a recursive function that will return the internal element that has focus,\n * even if it's inside a shadow root.\n *\n */\n\nimport { isEmpty } from '@springbokagency/stencil-base';\n\nexport function getActiveElement(root: Document | ShadowRoot = document): Element | null {\n  const activeEl = root.activeElement;\n\n  if (isEmpty(activeEl)) {\n    return null;\n  }\n\n  if (!isEmpty(activeEl.shadowRoot)) {\n    return getActiveElement(activeEl.shadowRoot);\n  }\n\n  return activeEl;\n}\n",":host {\n  @include reset-host;\n  height: 100%;\n}\n\n:host(.has-scale-transition) {\n  animation: modal-scale-open 0.6s $cubic-bezier;\n}\n\n:host(.has-scale-transition.is-closing) {\n  animation: modal-scale-close 0.6s $cubic-bezier;\n}\n\n:host(.has-fade-transition) {\n  animation: modal-fade-open 0.6s $cubic-bezier;\n}\n\n:host(.has-fade-transition.is-closing) {\n  animation: modal-fade-close 0.6s $cubic-bezier;\n}\n\n@keyframes modal-scale-open {\n  from {\n    opacity: 0;\n    transform: scale(1.05);\n  }\n\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n\n@keyframes modal-scale-close {\n  from {\n    opacity: 1;\n    transform: scale(1);\n  }\n\n  to {\n    opacity: 0;\n    transform: scale(1.05);\n  }\n}\n\n@keyframes modal-fade-open {\n  from {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes modal-fade-close {\n  from {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n}\n","/* eslint-disable @stencil-community/required-jsdoc */\n\nimport { Component, Host, h, Element, Method, Prop, Event, EventEmitter } from '@stencil/core';\nimport { isEmpty } from '@springbokagency/stencil-base';\n\nimport { getActiveElement } from '../../../utils/getActiveElement';\nimport type { BaseModalId, TransitionType } from './base-modal.types';\nimport { deepQuerySelectorAll } from '../../../utils/deepQuerySelectorAll';\n\n/**\n * Component containing all the modals \"focus trap\" logic\n * This is a way to get around StencilJS not allowing class inheritance\n *\n * Each modal that requires focus trap functionality\n * needs to be nested inside this base component\n */\n@Component({\n  tag: 'bs-base-modal',\n  styleUrl: 'base-modal.scss',\n  shadow: true,\n})\nexport class BsBaseModal {\n  private previousFocusedElement: Element;\n\n  private focusableElements: Element[] | [];\n\n  private firstFocusableElement: Element;\n\n  private lastFocusableElement: Element;\n\n  @Element() el!: HTMLBsBaseModalElement;\n\n  /**\n   * Props\n   */\n\n  @Prop() modalId: BaseModalId;\n\n  @Prop() transitionType?: TransitionType = 'fade';\n\n  @Prop() modalCanBeClosed?: boolean = true; // usefull with nested modals\n\n  /**\n   * Events\n   */\n\n  @Event() bsModalIsClosing: EventEmitter<{ modalId: BaseModalId }>;\n\n  @Event() bsModalIsClosed: EventEmitter<{ modalId: BaseModalId }>;\n\n  @Event() bsNextSlideAction: EventEmitter;\n\n  @Event() bsPreviousSlideAction: EventEmitter;\n\n  /**\n   * Methods\n   */\n\n  @Method()\n  async close() {\n    if (!this.modalCanBeClosed) return;\n\n    this.bsModalIsClosing.emit({ modalId: this.modalId });\n\n    // animate modal closing\n    this.el.classList.add('is-closing');\n\n    // enable website scroll\n    document.documentElement.classList.remove('modal-is-open');\n\n    // when transition is finished, remove modal\n    this.el.addEventListener('animationend', () => {\n      this.bsModalIsClosed.emit({ modalId: this.modalId });\n    });\n  }\n\n  @Method()\n  async nextSlide() {\n    this.bsNextSlideAction.emit();\n  }\n\n  @Method()\n  async previousSlide() {\n    this.bsPreviousSlideAction.emit();\n  }\n\n  @Method()\n  async handleFocus() {\n    // focus trap\n    this.focusableElements = deepQuerySelectorAll(\n      'button:not([disabled]), a:not([disabled]), input:not([disabled]), [tabindex]:not([tabindex=\"-1\"]',\n      this.el.firstElementChild\n    );\n\n    [this.firstFocusableElement] = this.focusableElements;\n    this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];\n\n    // focus modal's first element\n    (this.firstFocusableElement as HTMLElement)?.focus({ preventScroll: true });\n  }\n\n  private handleKeyPress(e: KeyboardEvent) {\n    // handle focus trap on \"Tab\" key press\n    if (e.key === 'Tab') this.handleFocusTrap(e);\n\n    // close modal on \"ESC\" key press\n    if (e.key === 'Escape') this.close();\n  }\n\n  private handleFocusTrap(e: KeyboardEvent) {\n    const shiftKeyIsPressed = e.shiftKey;\n\n    if (shiftKeyIsPressed) {\n      if (getActiveElement() === this.firstFocusableElement) {\n        // add focus for the last focusable element\n        (this.lastFocusableElement as HTMLElement).focus({ preventScroll: true });\n        e.preventDefault();\n      }\n    } else if (getActiveElement() === this.lastFocusableElement) {\n      // add focus for the last focusable element\n      (this.firstFocusableElement as HTMLElement).focus({ preventScroll: true });\n      e.preventDefault();\n    }\n  }\n\n  /**\n   * Lifecycle Hooks\n   */\n\n  componentDidLoad() {\n    document.addEventListener('keydown', this.handleKeyPress.bind(this));\n\n    // disable website scroll\n    document.documentElement.classList.add('modal-is-open');\n\n    this.handleFocus();\n\n    // save last page focused element (before modal opening)\n    this.previousFocusedElement = getActiveElement();\n  }\n\n  disconnectedCallback() {\n    document.removeEventListener('keydown', this.handleKeyPress.bind(this));\n\n    // re-focus last main-content's focused element (before modal opening)\n    (this.previousFocusedElement as HTMLElement)?.focus();\n  }\n\n  render() {\n    return (\n      <Host\n        class={`${!isEmpty(this.transitionType) ? `has-${this.transitionType}-transition` : ''}`}\n      >\n        <slot />\n      </Host>\n    );\n  }\n}\n",".bs-container {\n  display: block;\n  gap: rem(12);\n  width: 100%;\n  max-width: rem(3840);\n  margin-right: auto !important;\n  margin-left: auto !important;\n\n  @include mq('min', 'lg') {\n    gap: rem(24);\n  }\n\n  &.is-contained {\n    @include container-middle-view;\n  }\n\n  &.is-mobile-full-width {\n    column-gap: 0;\n\n    @include mq('max', 'lg') {\n      max-width: unset;\n    }\n  }\n}\n","import { Component, Host, Prop, h } from '@stencil/core';\n\n/**\n * The container component.\n */\n@Component({\n  tag: 'bs-container',\n  styleUrl: 'container.scss',\n  shadow: false,\n})\nexport class BsContainer {\n  /** Props */\n  /**\n   * Should the content be centered with a max width on mobile?\n   */\n  @Prop() mobileFullWidth?: boolean = false;\n\n  /**\n   * Should the content be centered with a max width on desktop?\n   */\n  @Prop() contained?: boolean = false;\n\n  render() {\n    return (\n      <Host\n        class={`bs-container ${this.mobileFullWidth ? 'is-mobile-full-width' : ''} ${\n          this.contained ? 'is-contained' : ''\n        }`}\n      >\n        <slot />\n      </Host>\n    );\n  }\n}\n"],"mappings":"iJAagBA,EAAiBC,EAA8BC,UAC7D,MAAMC,EAAWF,EAAKG,cAEtB,GAAIC,EAAQF,GAAW,CACrB,OAAO,I,CAGT,IAAKE,EAAQF,EAASG,YAAa,CACjC,OAAON,EAAiBG,EAASG,W,CAGnC,OAAOH,CACT,CCzBA,MAAMI,EAAe,0vO,MCqBRC,EAAW,M,0RAiBoB,O,sBAEL,I,CAmBrCC,cACE,IAAKC,KAAKC,iBAAkB,OAE5BD,KAAKE,iBAAiBC,KAAK,CAAEC,QAASJ,KAAKI,UAG3CJ,KAAKK,GAAGC,UAAUC,IAAI,cAGtBf,SAASgB,gBAAgBF,UAAUG,OAAO,iBAG1CT,KAAKK,GAAGK,iBAAiB,gBAAgB,KACvCV,KAAKW,gBAAgBR,KAAK,CAAEC,QAASJ,KAAKI,SAAU,G,CAKxDL,kBACEC,KAAKY,kBAAkBT,M,CAIzBJ,sBACEC,KAAKa,sBAAsBV,M,CAI7BJ,oB,MAEEC,KAAKc,kBAAoBC,EACvB,mGACAf,KAAKK,GAAGW,oBAGThB,KAAKiB,uBAAyBjB,KAAKc,kBACpCd,KAAKkB,qBAAuBlB,KAAKc,kBAAkBd,KAAKc,kBAAkBK,OAAS,IAGnFC,EAACpB,KAAKiB,yBAAqC,MAAAG,SAAA,SAAAA,EAAEC,MAAM,CAAEC,cAAe,M,CAG9DC,eAAeC,GAErB,GAAIA,EAAEC,MAAQ,MAAOzB,KAAK0B,gBAAgBF,GAG1C,GAAIA,EAAEC,MAAQ,SAAUzB,KAAK2B,O,CAGvBD,gBAAgBF,GACtB,MAAMI,EAAoBJ,EAAEK,SAE5B,GAAID,EAAmB,CACrB,GAAItC,MAAuBU,KAAKiB,sBAAuB,CAEpDjB,KAAKkB,qBAAqCG,MAAM,CAAEC,cAAe,OAClEE,EAAEM,gB,OAEC,GAAIxC,MAAuBU,KAAKkB,qBAAsB,CAE1DlB,KAAKiB,sBAAsCI,MAAM,CAAEC,cAAe,OACnEE,EAAEM,gB,EAQNC,mBACEvC,SAASkB,iBAAiB,UAAWV,KAAKuB,eAAeS,KAAKhC,OAG9DR,SAASgB,gBAAgBF,UAAUC,IAAI,iBAEvCP,KAAKiC,cAGLjC,KAAKkC,uBAAyB5C,G,CAGhC6C,uB,MACE3C,SAAS4C,oBAAoB,UAAWpC,KAAKuB,eAAeS,KAAKhC,QAGjEoB,EAACpB,KAAKkC,0BAAsC,MAAAd,SAAA,SAAAA,EAAEC,O,CAGhDgB,SACE,OACEC,EAACC,EAAI,CACHC,MAAO,IAAI7C,EAAQK,KAAKyC,gBAAkB,OAAOzC,KAAKyC,4BAA8B,MAEpFH,EAAA,a,qCCzJR,MAAMI,EAAe,qmO,MCURC,EAAW,M,8CAKc,M,eAKN,K,CAE9BN,SACE,OACEC,EAACC,EAAI,CACHC,MAAO,gBAAgBxC,KAAK4C,gBAAkB,uBAAyB,MACrE5C,KAAK6C,UAAY,eAAiB,MAGpCP,EAAA,a"}